#include <avr/io.h>
#include <avr/interrupt.h>

// Массивы, определяющие пины и периоды для каждого из светодиодов.
const uint8_t led_pins[] = {PB0, PB1, PB2, PB4, PB5}; // Пины D8, D9, D10, D12, D13

// Период теперь задается в "тиках" по 40 мс.
// Например, период 10 означает, что светодиод переключается каждые 10 * 40 мс = 400 мс.
const int led_periods[] = {10, 20, 30, 40, 50};
const int NUM_LEDS = 5;

// Глобальный счётчик прерываний. Ключевое слово 'volatile' гарантирует,
// что компилятор будет обращаться к переменной напрямую из памяти,
// что критически важно для переменных, изменяемых в ISR.
volatile unsigned long timer_ticks = 0;

void setup() {
  // Формирование битовой маски для настройки всех пинов одновременно
  uint8_t pin_mask = 0;
  for (int i = 0; i < NUM_LEDS; i++) {
    pin_mask |= (1 << led_pins[i]);
  }

  // Настройка пинов порта B как выходов
  DDRB |= pin_mask;
  // Установка начального состояния светодиодов (выключено)
  PORTB &= ~pin_mask;

  // Глобальное отключение прерываний на время настройки таймера
  cli();

  // Инициализация управляющих регистров Таймера1
  TCCR1A = 0;
  TCCR1B = 0;
  
  // Установка режима CTC (сброс по совпадению)
  TCCR1B |= (1 << WGM12);
  // Установка предделителя на 64
  TCCR1B |= (1 << CS11) | (1 << CS10);
  
  // Запись рассчитанного значения в регистр сравнения для интервала в 40 мс
  OCR1A = 9999;
  
  // Разрешение прерывания по совпадению с регистром OCR1A
  TIMSK1 |= (1 << OCIE1A);

  // Глобальное разрешение прерываний
  sei();
}

// Обработчик прерывания ISR (Interrupt Service Routine) для Таймера1
// Этот код выполняется автоматически каждые 40 мс
ISR(TIMER1_COMPA_vect) {
  // Инкремент счётчика тиков
  timer_ticks++;

  // Цикл проверки и переключения состояния каждого светодиода
  for (int i = 0; i < NUM_LEDS; i++) {
    if (timer_ticks % led_periods[i] == 0) {
      // Инвертирование состояния пина с помощью операции XOR
      PORTB ^= (1 << led_pins[i]);
    }
  }
}

// Основной цикл программы
void loop() {
  // Основной цикл свободен, так как вся логика выполняется асинхронно
  // в обработчике прерывания.
}
