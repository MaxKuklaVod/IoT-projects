#include <avr/io.h>
#include <avr/interrupt.h>

// Массивы с пинами и периодами мигания для каждого светодиода.
// Удобно, если захотим что-то поменять или добавить ещё светодиодов.
const uint8_t led_pins[] = {PB0, PB1, PB2, PB4, PB5};
const int led_periods[] = {10, 20, 30, 40, 50};
const int NUM_LEDS = 5;

// Наш счётчик тиков таймера. Он 'volatile', потому что меняется в прерывании.
volatile unsigned long timer_ticks = 0;

void setup() {
  // Настраиваем пины на выход через регистры (это быстрее, чем pinMode)
  uint8_t pin_mask = 0;
  for (int i = 0; i < NUM_LEDS; i++) {
    pin_mask |= (1 << led_pins[i]);
  }
  DDRB |= pin_mask;    // Установить пины как выходы
  PORTB &= ~pin_mask;  // Выключить светодиоды при старте

  // Настраиваем Таймер1
  cli(); // Выключаем все прерывания, чтобы нам не мешали

  TCCR1A = 0; // Сбрасываем регистры таймера
  TCCR1B = 0;
  
  TCCR1B |= (1 << WGM12);             // Включаем режим CTC
  TCCR1B |= (1 << CS11) | (1 << CS10); // Устанавливаем предделитель 64
  
  OCR1A = 2499; // Задаём "потолок" счёта для получения интервала 10 мс
  TIMSK1 |= (1 << OCIE1A); // Разрешаем прерывание по совпадению

  sei(); // Включаем прерывания обратно
}

// Это специальная функция — обработчик прерывания. Она вызывается сама!
ISR(TIMER1_COMPA_vect) {
  timer_ticks++; // Увеличиваем наш счётчик

  // Пробегаемся по всем светодиодам
  for (int i = 0; i < NUM_LEDS; i++) {
    // Если счётчик делится нацело на период светодиода...
    if (timer_ticks % led_periods[i] == 0) {
      // ...то переключаем его состояние!
      PORTB ^= (1 << led_pins[i]);
    }
  }
}

void loop() {
  // Пусто! Процессор свободен и ждёт новых задач.
}
