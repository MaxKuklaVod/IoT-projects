# Реализация программного UART (myUART) на Arduino Uno

## 1. Введение и постановка задачи

### 1.1. Цель проекта
Целью данного проекта является разработка и реализация программного асинхронного последовательного приемопередатчика (UART) на микроконтроллере ATmega328P (платформа Arduino Uno). В отличие от использования встроенного аппаратного модуля `USART`, данное решение полагается исключительно на стандартные порты ввода-вывода (GPIO), один 16-битный аппаратный таймер (Timer1) и систему прерываний микроконтроллера.

Задача заключается в создании API, позволяющего асинхронно отправлять и принимать данные через кольцевые буферы, не блокируя основной цикл программы `loop()`.

### 1.2. Проблема стандартных подходов
Стандартная библиотека `SoftwareSerial` решает подобную задачу, однако цель данного проекта — реализовать эту функциональность с нуля для глубокого понимания принципов работы протокола и низкоуровневого программирования. Использование блокирующих функций, таких как `delay()`, для формирования временных интервалов недопустимо, так как это полностью останавливает выполнение других задач.

### 1.3. Предложенное решение
Для реализации неблокирующей асинхронной связи используется механизм аппаратных прерываний, генерируемых **Таймером1**. Этот таймер настроен для точного отсчета времени, необходимого для формирования (передачи) и считывания (приема) каждого бита. Для обеспечения одновременной работы TX и RX используются два независимых канала сравнения одного и того же таймера. Вся логика приема и передачи вынесена в обработчики прерываний (ISR), что позволяет этим процессам работать в фоновом режиме.

## 2. Архитектура и программная реализация

### 2.1. Управление таймером (Timer1)
16-битный **Таймер1** является ядром всей системы.
*   **Предделитель (Prescaler):** Установлен на 8. При тактовой частоте 16 МГц это дает разрешение таймера `(16,000,000 / 8)^-1 = 0.5` микросекунды на один тик.
*   **Два канала сравнения:** Для реализации одновременной (полнодуплексной) работы используются два независимых канала прерываний по совпадению:
    *   **Канал A (`TIMER1_COMPA_vect`)**: Управляет передатчиком (TX).
    *   **Канал B (`TIMER1_COMPB_vect`)**: Управляет приемником (RX).
*   **Длительность бита:** Количество тиков таймера, соответствующее одному биту, рассчитывается по формуле: `ticks = (F_CPU / prescaler) / baud_rate`. Для скорости 9600 бод это значение составляет `(16,000,000 / 8) / 9600 ≈ 208` тиков.

### 2.2. Логика Передатчика (TX)
Процесс передачи представляет собой конечный автомат, управляемый прерыванием `TIMER1_COMPA_vect`.
1.  **Инициация:** Функция `uart_send()` помещает байт в кольцевой буфер `tx_buffer` и, если передатчик был в простое, активирует прерывания для канала A.
2.  **Работа ISR:**
    *   **Стартовый бит:** Из буфера извлекается байт, пин `TX_PIN` (D3) устанавливается в `LOW`, и таймер настраивается на срабатывание через `Tbit`.
    *   **Биты данных:** При каждом последующем прерывании на `TX_PIN` последовательно выставляются 8 бит данных (от LSB к MSB).
    *   **Стоповый бит:** Пин `TX_PIN` устанавливается в `HIGH`.
3.  **Завершение:** Если в буфере есть еще данные, процесс повторяется. Если буфер пуст, прерывания для канала A отключаются до следующего вызова `uart_send()`.

### 2.3. Логика Приемника (RX)
Процесс приема использует комбинацию внешнего прерывания и прерывания таймера.
1.  **Обнаружение старта:** Внешнее прерывание `INT0` (на пине `RX_PIN`, D2) настроено на срабатывание по **спадающему фронту** (`HIGH` -> `LOW`), что соответствует началу стартового бита.
2.  **Синхронизация:** В обработчике `INT0_vect` внешнее прерывание отключается, а таймер (канал B) настраивается на срабатывание через **1.5 длительности бита**. Это позволяет "прицелиться" точно в середину первого бита данных.
3.  **Считывание данных:** Прерывание `TIMER1_COMPB_vect` срабатывает через каждый `Tbit`, считывая состояние пина `RX_PIN` и формируя байт данных.
4.  **Завершение:** После проверки стопового бита принятый байт помещается в кольцевой буфер `rx_buffer`, прерывание таймера для канала B отключается, а внешнее прерывание `INT0` снова активируется.

### 2.4. Прямое управление портами
В соответствии с требованиями, настройка пинов осуществляется напрямую через регистры `DDRD` (направление) и `PORTD` (состояние), что обеспечивает максимальную производительность и позволяет избежать накладных расходов функций Arduino `pinMode()` и `digitalWrite()`.

## 3. Тестирование и верификация

### 3.1. Методология тестирования
Для проверки работоспособности `myUART` были использованы две разные тестовые среды.

*   **Тест на реальном оборудовании (Arduino Uno + Arduino Nano):**
    *   **Arduino Uno ("Ведущая"):** Запущена полная реализация программного UART `myUART`.
    *   **Arduino Nano ("Эхо"):** Запущена простая эхо-программа, использующая ее **аппаратный UART** (пины D0, D1).
    *   **Соединение:** TX (`D3`) Uno подключен к RX (`D0`) Nano, а RX (`D2`) Uno — к TX (`D1`) Nano. Также соединены `GND` и `5V`.

*   **Тест в симуляторе Tinkercad (Arduino Uno + Arduino Uno):**
    *   **Причина отличий:** Tinkercad не позволяет удалить USB-подключение со второй платы, что создает **аппаратный конфликт** на ее пинах D0 и D1.
    *   **Решение:** На второй, "ведомой" плате, была использована стандартная библиотека **`SoftwareSerial`** на пинах D10 и D11 для создания эхо-сервера, что позволило обойти конфликт.

### 3.2. Анализ результатов
В ходе тестирования было установлено, что **сигнал успешно передается и принимается**. При отправке данных с ведущей платы, ведомая плата получает их и отправляет ответ, который успешно принимается ведущей платой. Это подтверждается тем, что функция `uart_available()` на ведущей плате сообщает о наличии данных в буфере.

Однако, сами **данные оказались искажены**. Вместо отправленных символов в ответ приходили "мусорные" данные (звездочки, непечатаемые символы).

**Причина искажения данных:**
Основная причина кроется в **небольшой ошибке синхронизации**, которая накапливается в течение передачи одного байта.
*   **Ошибка округления:** При расчете количества тиков таймера на один бит для скорости 9600 бод мы получаем: `(16,000,000 / 8) / 9600 = 208.333...`. В коде используется целочисленное значение `208`.
*   **Накопление ошибки:** Эта разница в `0.333` тика (0.1665 мкс) накапливается с каждым битом. К моменту считывания 8-го бита данных, расхождение во времени между передатчиком и приемником уже может быть достаточным, чтобы считывание произошло не в середине бита, а на его границе, что приводит к неверной интерпретации данных.
*   **Ошибка кадрирования (Framing Error):** К моменту проверки стопового бита (10-й бит в кадре), ошибка может привести к тому, что приемник считает стоповый бит в неверный момент времени. Обнаружив `LOW` вместо ожидаемого `HIGH`, он считает, что произошла ошибка, и отбрасывает байт или записывает в буфер "мусор".

## 4. Исходные коды и ресурсы

### 4.1. Код для тестирования на реальном оборудовании

**Код для Arduino Uno (myUART):**
```cpp
#include <avr/io.h>
#include <avr/interrupt.h>

// --- Конфигурация пинов и буферов ---
#define RX_PIN      PD2 // Пин для приема (INT0)
#define TX_PIN      PD3 // Пин для передачи

#define BUFFER_SIZE 64  // Размер кольцевых буферов

// --- Глобальные переменные (volatile) ---
volatile char tx_buffer[BUFFER_SIZE];
volatile uint8_t tx_head = 0, tx_tail = 0;
volatile char rx_buffer[BUFFER_SIZE];
volatile uint8_t rx_head = 0, rx_tail = 0;
volatile uint16_t timer_ticks_per_bit, timer_ticks_per_half_bit;

enum TX_STATE { TX_IDLE, TX_START, TX_DATA, TX_STOP };
enum RX_STATE { RX_IDLE, RX_DATA, RX_STOP };
volatile TX_STATE tx_state = TX_IDLE;
volatile RX_STATE rx_state = RX_IDLE;
volatile uint8_t tx_byte_to_send, tx_bit_index;
volatile uint8_t rx_byte_received, rx_bit_index;

// --- API функции ---
void uart_set_baudrate(int rate) {
    timer_ticks_per_bit = (16000000 / 8) / rate;
    timer_ticks_per_half_bit = timer_ticks_per_bit / 2;
}

void uart_send(char b) {
    uint8_t next_head = (tx_head + 1) % BUFFER_SIZE;
    while (next_head == tx_tail); // Ждем, если буфер полон
    tx_buffer[tx_head] = b;
    tx_head = next_head;
    cli();
    if (tx_state == TX_IDLE) {
        tx_state = TX_START;
        TIMSK1 |= (1 << OCIE1A);
        OCR1A = TCNT1 + 10;
    }
    sei();
}

void uart_send_string(const char *msg) { while (*msg) uart_send(*msg++); }
uint8_t uart_available() { cli(); uint8_t head = rx_head, tail = rx_tail; sei(); return (head - tail + BUFFER_SIZE) % BUFFER_SIZE; }
char uart_read() { if (rx_head == rx_tail) return -1; char data = rx_buffer[rx_tail]; rx_tail = (rx_tail + 1) % BUFFER_SIZE; return data; }
bool uart_read_string(char *rx_data) { if (uart_available() == 0) return false; int i = 0; while(uart_available()) rx_data[i++] = uart_read(); rx_data[i] = '\0'; return true; }

// --- Обработчики прерываний ---
ISR(TIMER1_COMPA_vect) {
    switch (tx_state) {
        case TX_START: PORTD &= ~(1 << TX_PIN); tx_bit_index = 0; tx_state = TX_DATA; OCR1A += timer_ticks_per_bit; break;
        case TX_DATA: if (tx_bit_index < 8) { if ((tx_byte_to_send >> tx_bit_index) & 1) PORTD |= (1 << TX_PIN); else PORTD &= ~(1 << TX_PIN); tx_bit_index++; OCR1A += timer_ticks_per_bit; } else { tx_state = TX_STOP; } break;
        case TX_STOP: PORTD |= (1 << TX_PIN); tx_state = TX_IDLE; OCR1A += timer_ticks_per_bit; break;
        case TX_IDLE: default: if (tx_head != tx_tail) { tx_byte_to_send = tx_buffer[tx_tail]; tx_tail = (tx_tail + 1) % BUFFER_SIZE; tx_state = TX_START; } else { TIMSK1 &= ~(1 << OCIE1A); } break;
    }
}
ISR(TIMER1_COMPB_vect) {
    switch(rx_state) {
        case RX_DATA: if (rx_bit_index < 8) { if (PIND & (1 << RX_PIN)) rx_byte_received |= (1 << rx_bit_index); rx_bit_index++; OCR1B += timer_ticks_per_bit; } else { rx_state = RX_STOP; } break;
        case RX_STOP: if (PIND & (1 << RX_PIN)) { uint8_t next_head = (rx_head + 1) % BUFFER_SIZE; if (next_head != rx_tail) { rx_buffer[rx_head] = rx_byte_received; rx_head = next_head; } } rx_state = RX_IDLE; break;
        case RX_IDLE: default: TIMSK1 &= ~(1 << OCIE1B); EIFR |= (1 << INTF0); EIMSK |= (1 << INT0); break;
    }
}
ISR(INT0_vect) {
    EIMSK &= ~(1 << INT0); rx_state = RX_DATA; rx_bit_index = 0; rx_byte_received = 0; OCR1B = TCNT1 + timer_ticks_per_half_bit + timer_ticks_per_bit; TIMSK1 |= (1 << OCIE1B);
}

// --- Основная программа ---
void setup() {
    uart_set_baudrate(9600);
  
    // Настройка пинов (TX=PD3, RX=PD2)
    DDRD |= (1 << TX_PIN);  
    PORTD |= (1 << TX_PIN); 
    DDRD &= ~(1 << RX_PIN); 
    PORTD |= (1 << RX_PIN); 

    // Настройка таймера и прерываний
    TCCR1A = 0; TCCR1B = (1 << CS11); 
    EICRA |= (1 << ISC01); EIMSK |= (1 << INT0);  
    
    // Включаем аппаратный Serial для общения с ПК
    Serial.begin(9600);
    Serial.println("Software UART Test. Type something to send to the echo board.");
    
    sei(); // Разрешаем все прерывания
}

void loop() {
  // 1. Если пришли данные с компьютера, отправляем их через программный UART
  if (Serial.available()) {
    char c = Serial.read();
    uart_send(c);
  }

  // 2. Если пришли данные на программный UART, выводим их на компьютер
  if (uart_available()) {
    char c = uart_read();
    Serial.write(c);
  }
}
```

**Код для Arduino Nano (аппаратное эхо):**
```cpp
void setup() {
  // Инициализируем аппаратный Serial на скорости 9600
  Serial.begin(9600);
}

void loop() {
  // Если на аппаратный Serial (пин D0) пришли данные...
  if (Serial.available()) {
    // ...считываем байт...
    char receivedChar = Serial.read();
    // ...и немедленно отправляем его обратно через тот же Serial (пин D1).
    Serial.write(receivedChar);
  }
}
```

### 4.2. Код для симуляции в Tinkercad

**Код для первой Arduino Uno (myUART):**
*(Код тот же, что и для реального оборудования)*

**Код для второй Arduino Uno (программное эхо):**
```cpp
#include <SoftwareSerial.h>

// Создаем программный последовательный порт
// Пин 10 будет RX, Пин 11 будет TX
SoftwareSerial mySoftwareSerial(10, 11); 

void setup() {
  // Запускаем аппаратный Serial (для отладки, если понадобится)
  Serial.begin(9600);
  
  // Запускаем наш программный Serial
  mySoftwareSerial.begin(9600);
}

void loop() {
  // Если на наш программный Serial (пин 10) пришли данные...
  if (mySoftwareSerial.available()) {
    // ...считываем байт...
    char receivedChar = mySoftwareSerial.read();
    // ...и немедленно отправляем его обратно через тот же программный Serial (пин 11).
    mySoftwareSerial.write(receivedChar);
  }
}
```

### 4.3. Ссылки

### 4.3.1 Симуляция в Tinkercad

Корректность работы схемы и программного кода была проверена с помощью онлайн-симулятора Tinkercad. 

**[Ссылка для доступа к симуляции](https://www.tinkercad.com/things/jmKbRd0RVhH-frantic-fulffy-tumelo?sharecode=D4XbMbbsOMlQLH5BYb0IYLbINIOVKzrpdF427ruN2BY)**

### 4.3.2 Видеодемонстрация

В качестве финального подтверждения работоспособности прилагается видеозапись работы схемы на физической плате Arduino UNO.

<video width="320" height="240" controls>
  <source src="video.mp4" type="video/mp4">
</video>

## 5. Заключение

**Основная цель проекта — реализация асинхронной передачи и приема данных с помощью прерываний — была успешно достигнута.** Система корректно формирует UART-кадры, обнаруживает начало передачи и считывает данные в фоновом режиме, не блокируя основной цикл.

Несмотря на проблему с целостностью данных, фундаментальная работоспособность механизма доказана. Проблема синхронизации является классической для программных реализаций протоколов и может быть решена путем более точной калибровки таймингов или введением более сложной логики синхронизации. Проект является отличной демонстрацией низкоуровневого управления микроконтроллером и работы с прерываниями.